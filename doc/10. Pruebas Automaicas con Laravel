10. Pruebas Automaicas con Laravel

Revisando la estructura en la carpeta 

/test

Existen dos tipos de test 

	/Feature

	/Unit


El primero son test de caracteristicas donde se testean diferentes componentes que interactuan entre ellos y en la segunda se testean piezas especificas de codigo, como una clase, una funcion etc.

De momento solo se probara con la primera pcion

Podremos eleimiar por tanto El ejemplo de las pruebas unitarias


Ahora podremos ejecutar en terminal:

php artisan test


Existe un error en este test:

  • Tests\Feature\ExampleTest > the application returns a successful response
  Expected response status code [200] but received 404.
  Failed asserting that 200 is identical to 404.

  at tests/Feature/ExampleTest.php:19
     15▕     public function test_the_application_returns_a_successful_response()
     16▕     {
     17▕         $response = $this->get('/');
     18▕ 
  ➜  19▕         $response->assertStatus(200);
     20▕     }
     21▕ }
     22▕ 


  Tests:  1 failed
  Time:   0.13s




Esto es por que se ha quitado la ruta de inicio 

Otra forma de ejecutar los test es de la siguiete manera:

 Eliminamos el contenido del metodo:

 class ExampleTest extends TestCase
{
    
}


Y ahora serenomba como: BooksApiTest.php

Actualizando el nombre del metodo


class BooksApiTest extends TestCase
{
    
}


Ahor alo primero que hay que testear es que se pueden ller todos los libros

class BooksApiTest extends TestCase
{
    function can_get_all_books()
    {
        
    }
}



Para poder probar que se recibieron los libros, es necesario tener libros en la BD


<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class BooksApiTest extends TestCase
{
    use RefreshDatabase;

    function can_get_all_books()
    {

    }
}




Es importante configurar la BD para los test

Ahora se tiene datos cuando se hagan las pruebas en local desde el navegador pero es necesario otra bd para cuando ejecutamos los test y no queremos que se eliminen los datos que estan probandose desde el navegador, por lo que se configura un aBD para los test


Para ello en el archivo

phpunit.xml


En donde por defecto se tiene SQL y en memoria, vamos a cambiar el nombre de la bd, vamos a utilizar la bd con el nombre:
<env name="DB_DATABASE" value="books_test"/>

Esta base de datso no existe por lo que hay que crearla

Ahora para crear un libro de prueba, al ejecutar el comando 

phpmake module con todas las opcoines que le agregamos al principio se nos agrego tambien el factory

BookFactory.php

Esta clase nos va a crear registros de prueba, por  lo que se debe definir que campos queremos que se llene,
en el caso de title y que los llene a traves del faker con una oracion aleatoria como titulo del libro.


En: 

/database/factories/BookFactory.php



 public function definition()
    {
        return [
            'title' => $this->faker->sentence();
        ];
    }

  Ya qe con faker nos va a generar una oracion aleatoria y se guardara en el campo title


  Ahora para utilizar ese factory en el archivo

  test/Feature/BooksApiTest.php


  Podemos crear una variable con el modelo book, llamar al modelo factory y con el metodo create decirle que cree un libro.

  Es importante importar el modelo en la parte de arriba.

  Inspeccionando con el metodo dd

  Se podra ejecutar el test;

  La prueba completa es:

  ---
    <?php

    namespace Tests\Feature;

    use App\Models\Book;

    use Illuminate\Foundation\Testing\RefreshDatabase;
    use Tests\TestCase;

    class BooksApiTest extends TestCase
    {
        use RefreshDatabase;

        /** @test */

        function can_get_all_books()
        {

            $book = Book::factory()->create();

            dd($book); //dom by die o dye dom para inspeccionar este libro
            
            

            
        }
    }


  ---

En consola ejecutamos la prueba:
php artisan test

Generando la siguiente salida en terminal:

---
        App\Models\Book^ {#2184 // tests/Feature/BooksApiTest.php:21
  #connection: "mysql"
  #table: null
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  +preventsLazyLoading: false
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: true
  #escapeWhenCastingToString: false
  #attributes: array:4 [
    "title" => "Autem aut voluptatem voluptas quo minima aliquid quas dolorum."
    "updated_at" => "2022-11-02 18:34:48"
    "created_at" => "2022-11-02 18:34:48"
    "id" => 1
  ]
  #original: array:4 [
    "title" => "Autem aut voluptatem voluptas quo minima aliquid quas dolorum."
    "updated_at" => "2022-11-02 18:34:48"
    "created_at" => "2022-11-02 18:34:48"
    "id" => 1
  ]
  #changes: []
  #casts: []
  #classCastCache: []
  #attributeCastCache: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: []
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #fillable: []
  #guarded: array:1 [
    0 => "*"
  ]
}
 
---

Alo que podremos verificar con las tablas creadas:

MariaDB [books_test]> show tables;
+------------------------+
| Tables_in_books_test   |
+------------------------+
| books                  |
| failed_jobs            |
| migrations             |
| password_resets        |
| personal_access_tokens |
| users                  |
+------------------------+
6 rows in set (0.001 sec)


Con su respectivo contenido de cada tabla:

La primer tabla esta vacia.
Books

La segunda tabla tambien esta vacio:
failed:jobs

En la tercera tabla es donde existe contenido:

MariaDB [books_test]> select * from migrations;
+----+-------------------------------------------------------+-------+
| id | migration                                             | batch |
+----+-------------------------------------------------------+-------+
|  1 | 2014_10_12_000000_create_users_table                  |     1 |
|  2 | 2014_10_12_100000_create_password_resets_table        |     1 |
|  3 | 2019_08_19_000000_create_failed_jobs_table            |     1 |
|  4 | 2019_12_14_000001_create_personal_access_tokens_table |     1 |
|  5 | 2022_11_02_040718_create_books_table                  |     1 |
+----+-------------------------------------------------------+-------+
5 rows in set (0.001 sec)


Password_resets tambien esta vacia
password_resets


Vacia tambien 
personal_access_tokens

y la tabla de usuarios tambien esta vacia:
users;





Al ejecutar las pruebas tambien se pueden ejecutar multiples libros en la base de datos pasando un numero.

Suponiendo que se quieren cuatro libros:

---
   $books = Book::factory(4)->create();

        dd($books->count()); //Se cuentan los libros
        
---

Se ejecuta la prueba:

php artisan test

Para verificar que son cuatro

php artisan test
 4 // tests/Feature/BooksApiTest.php:27
 
Una vez que se tienen los libros en la base de datos se hara una peticion de tipo GET

---
   $books = Book::factory(4)->create();

   $this->get('/api/books')->dump() //Dump para inspeccionar la respuesta
        
---

Se ejecuta nueva mente la prueba el resultado es:

---
php artisan test
 array:4 [ // vendor/laravel/framework/src/Illuminate/Testing/TestResponse.php:1460
  0 => {#2090
    +"id": 1
    +"title": "Aut aut velit iure provident vero similique."
    +"created_at": "2022-11-02T19:10:04.000000Z"
    +"updated_at": "2022-11-02T19:10:04.000000Z"
  }
  1 => {#2049
    +"id": 2
    +"title": "Praesentium repudiandae illum omnis sit qui ut dolore."
    +"created_at": "2022-11-02T19:10:04.000000Z"
    +"updated_at": "2022-11-02T19:10:04.000000Z"
  }
  2 => {#2179
    +"id": 3
    +"title": "Adipisci est officia sed modi ad."
    +"created_at": "2022-11-02T19:10:04.000000Z"
    +"updated_at": "2022-11-02T19:10:04.000000Z"
  }
  3 => {#2178
    +"id": 4
    +"title": "Id repellat sed qui distinctio."
    +"created_at": "2022-11-02T19:10:04.000000Z"
    +"updated_at": "2022-11-02T19:10:04.000000Z"
  }
]

---

Lo que se obtiene es un JSON con los cuatro libros que se generaron con factory.

